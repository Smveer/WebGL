<!DOCTYPE html>
<html lang="EN">
	<head>
		<title>Project WEBGL</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="../ressources/css/main.css">
        <style>
            .loader{
                position : fixed;
                width:100px;
                height:100px;
                top : 0px;
                left : 0px;
                z-index: 99999;	
                } 
    
            .rond_max_19{
                width:1400px;
                height:900px;
                background-image:url(logo1.png);
                background-position:center;
    
                background-repeat:no-repeat;
                -webkit-animation:anim_max 1.5s infinite linear;
                -moz-animation:anim_max 1.5s infinite linear;
                -ms-animation:anim_max 1.5s infinite linear;
                -o-animation:anim_max 1.5s infinite linear;
                animation:anim_max 1.5s infinite linear;
                position: absolute;
                opacity: 1;
    
            } 
    
            .rond_min_19{
                width:1400px;
                height:900px;
                background-image:url(logo2.png);
                background-position:center;background-repeat:no-repeat;
                -webkit-animation:anim_min 1.4s infinite linear;
                -moz-animation:anim_min 1.4s infinite linear;
                -ms-animation:anim_min 1.4s infinite linear;
                -o-animation:anim_min 1.4s infinite linear;
                animation:anim_min 1.4s infinite linear;
                position: absolute;
                opacity: 1;
    
            } 
    
            @-webkit-keyframes anim_max{
                0%{-webkit-transform:rotate(0deg);
                    -moz-transform:rotate(0deg);
                    -ms-transform:rotate(0deg);
                    transform:rotate(0deg)
                }
                
                100%{-webkit-transform:rotate(360deg);
                    -moz-transform:rotate(360deg);
                    -ms-transform:rotate(360deg);
                    transform:rotate(360deg)
                    }
                } 
    
             @-webkit-keyframes anim_min{
                 0%{-webkit-transform:rotate(0deg);
                     -moz-transform:rotate(0deg);
                     -ms-transform:rotate(0deg);
                     transform:rotate(0deg)
                    } 
    
                 100%{-webkit-transform:rotate(-720deg);
                     -moz-transform:rotate(-720deg);
                     -ms-transform:rotate(-720deg);
                     transform:rotate(-720deg)
                     }
            } 
    
             @-moz-keyframes anim_max{
                 0%{-webkit-transform:rotate(0deg);
                     -moz-transform:rotate(0deg);
                     -ms-transform:rotate(0deg);
                     transform:rotate(0deg)
                   } 
                 100%{-webkit-transform:rotate(360deg);
                     -moz-transform:rotate(360deg);
                     -ms-transform:rotate(360deg);
                     transform:rotate(360deg)
                     }
            } 
    
             @-moz-keyframes anim_min{
                 0%{-webkit-transform:rotate(0deg);
                     -moz-transform:rotate(0deg);
                     -ms-transform:rotate(0deg);
                     transform:rotate(0deg)
                     } 
                 100%{-webkit-transform:rotate(-720deg);
                     -moz-transform:rotate(-720deg);
                     -ms-transform:rotate(-720deg);
                     transform:rotate(-720deg)
                     }
                 } 
    
             @-ms-keyframes anim_max{
                 0%{-webkit-transform:rotate(0deg);
                     -moz-transform:rotate(0deg);
                     -ms-transform:rotate(0deg);
                     transform:rotate(0deg)
                 } 
                 100%{-webkit-transform:rotate(360deg);
                     -moz-transform:rotate(360deg);
                     -ms-transform:rotate(360deg);
                     transform:rotate(360deg)}} 
    
             @-ms-keyframes anim_min{
                 0%{-webkit-transform:rotate(0deg);
                     -moz-transform:rotate(0deg);
                     -ms-transform:rotate(0deg);
                     transform:rotate(0deg)
                 } 
                 100%{-webkit-transform:rotate(-720deg);
                     -moz-transform:rotate(-720deg);
                     -ms-transform:rotate(-720deg);
                     transform:rotate(-720deg)}
                 } 
    
             @keyframes anim_max{
                 0%{-webkit-transform:rotate(0deg);
                     -moz-transform:rotate(0deg);
                     -ms-transform:rotate(0deg);
                     transform:rotate(0deg)
                    } 
    
                 100%{-webkit-transform:rotate(360deg);
                     -moz-transform:rotate(360deg);
                     -ms-transform:rotate(360deg);
                     transform:rotate(360deg)
                    }
                 }
    
    
              @keyframes anim_min{
                  0%{-webkit-transform:rotate(0deg);
                      -moz-transform:rotate(0deg);
                      -ms-transform:rotate(0deg);
                      transform:rotate(0deg)
                  } 
                  100%{-webkit-transform:rotate(-720deg);
                      -moz-transform:rotate(-720deg);
                      -ms-transform:rotate(-720deg);transform:rotate(-720deg)
                      }
                  }
              
                #blocker {
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.1);
                    margin: 0;
                    padding: 0;
                }
    
                #instructions {
                    width: 100%;
                    height: 100%;
    
                    display: -webkit-box;
    
                    -webkit-box-pack: center;
                    -moz-box-pack: center;
                    box-pack: center;
    
                    -webkit-box-align: center;
                    -moz-box-align: center;
                    box-align: center;
    
                    color: #1ee565;
                    text-align: center;
                    font-family: Arial;
                    font-size: 14px;
                    line-height: 24px;
    
                    cursor: pointer;
                    margin: 0;
                    padding: 0;
    
                }
    
                 body{
                    
                    margin: 0;
                    padding: 0;
    
                 } 
            </style>
	</head>
	<body onload="myFunction()">
        <div id="blocker">

            <div id="instructions">
                <center><img src="../ressources/images/party.jpg" style="height: 380px;width: 650px; margin:10px;"></center>
                <b><span style="font-size:50px; color: #a56e3d ">Click to play </span>
                <i>
                <br /><br />

                <b>Move: ZQSD<br/>
                Jump: SPACE<br/>
                Look: MOUSE</i>

                <br /><br /></b>
                <span style="font-size:35px; color: #ffcf4f; font-family:OCR A Std, monospace"> Enjoy!</span>

            </div>

        </div>

        <div id="home">
                <img src="../ressources/images/home.png" style=" opacity: 1; position: absolute; margin: 0px; padding: 0; width:1490px; height: 810px">



            <center> <i><h1 style="margin: 250px; padding: 10px; font-family: Humming; color:#ffcf4f; font-size:70px; opacity: 1; position: absolute; width: 900px">Loading ...</h1></i> </center>

             <div class="loader">


                <div class="rond_max_19">
                    <div class="rond_min_19">

                    </div>
                </div>
            </div>
        </div>

        <script>
            var preloader= document.getElementById('home');

            function myFunction(){
                preloader.style.visibility= 'hidden';
                preloader.style.opacity= '0';

            }

        </script>
		<script type="module">

            //IMPORT DES DÉPENDANCES
            import * as THREE from '../build/three.module.js';
            import { PointerLockControls } from './jsm/controls/PointerLockControls.js'; // caméra pointerlockcontrols
            // import { OrbitControls } from "./jsm/controls/OrbitControls.js";
            import Stats from './jsm/libs/stats.module.js'; //pour voir les fps
            import { GUI } from './jsm/libs/dat.gui.module.js' //pour gui
            import { ColladaLoader } from './jsm/loaders/ColladaLoader.js'; // pour objet type collada
            import { FBXLoader } from './jsm/loaders/FBXLoader.js'; // pour objet type fbx
            import { Reflector } from './jsm/objects/Reflector.js'; // pour propriétés mirroir
    
            //Affichage des fps
            (function(fps){
                var script=document.createElement('script');
                script.onload=function(){ // Charge le script
                        var stats=new Stats();
                        document.body.appendChild(stats.dom);
                        requestAnimationFrame(function loop(){ // Permet de update les fps
                            stats.update();
                            requestAnimationFrame(loop)
                        });
                };

                script.src='//mrdoob.github.io/stats.js/build/stats.min.js';
                document.head.appendChild(script);
            })();

            //DÉCLARATIONS DES OBJETS DE LA SCÈNE
            var clock, camera, scene, renderer, controls, ambient, spotLight, lightHelper, spotLightMainBuildingMiddle;

            //DÉCLARATION POUR BONHOMME QUI DANSE (COLLADA)
            var mixer, stormtrooper;

            //DÉCLARATION POUR LA SOURIS QUI TWERK (FBX)
            var mixer2, mouse;

            var objs = [];

            //DÉCLARATION POUR LA CAMERA FPC (FIRST PERSON CONTROL)
            var objects = [];
            var raycaster;
            var moveForward = false;
            var moveBackward = false;
            var moveLeft = false;
            var moveRight = false;
            var canJump = false;
            var prevTime = performance.now();
            var velocity = new THREE.Vector3();
            var direction = new THREE.Vector3();
            var movSpeedX = 1;
            var movSpeedZ = 1;

            //SONS
            var voice, globalAudio, listener, audioLoader;

            //DÉCLARATION DE LA BASE 
            var mesh_floor, ground, leftWall, rightWall, frontWall, backWall;

            //DÉCLARATION DES TOURELLES DE LA BASE
            var turretBackLeft, turretBackRight, turretFrontLeft, turretFrontRight;

            //DÉCLARATION DE L'ENTRÉE
            var frontGateBig, frontGateSmall, miniTurretFrontLeft, miniTurretFrontRight, miniTurretBackLeft, miniTurretBackRight;

            //DÉCLARATION DES MINI TOURELLES DE LA TOURELLE GAUCHE
            var miniTurretFrontLeft_frontLeft, miniTurretFrontRight_frontLeft, miniTurretBackLeft_frontLeft, miniTurretBackRight_frontLeft;

            //DÉCLARATION DES MINI TOURELLES DE LA TOURELLE DROITE
            var miniTurretFrontLeft_frontRight, miniTurretFrontRight_frontRight, miniTurretBackLeft_frontRight, miniTurretBackRight_frontRight;

            //DÉCLARATION DES BATÎMENTS
            var mainBuilding, mainBuildingFront, mainBuildingLittleFront, mainBuildingMiddle;

            //DÉCLARATION DES MINI TOURELLES DES BATÎMENTS
            var miniTurretMainBuilding_frontLeft, miniTurretMainBuilding_frontRight;

            //DÉCLARATION DES OBJETS DES MINARETS
            var minaret_Base, minaret_LowerCylinder, minaret_deco2Base, minaret_deco1Base, minaret_BaseLinkOcto, minaret_LowerBalconyBottom, minaret_LowerBalconyTop;
            var minaret_MiddleCylinder, minaret_MiddleBalconyTop, minaret_MiddleBalconyBottom, minaret_HigherBalconyTop, minaret_HigherBalconyBottom;
            var minaret_SpikeBottom, minaret_Spike, minaret_SpikeCircle1, minaret_SpikeCircle2, minaret_SpikeTop, minaret_Moon;
           
            //DÉCLARATION DES DÔMES
            var sphere, cylindre, octogone;

            //CRÉATION DE LA CAMÉRA SUPER DYNAMIQUE
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth/window.innerHeight, 1, 1000000 );
            camera.position.set( 0, 1000, 12000 );

			init(); //Pour créer la scène
			animate(); //Pour animer la scène (boucle qui tourne en permanence)
            
			function init() {
                
                // MISE EN PLACE DU POINTER LOCK CONTROL, CONTROLEUR DE LA SCENE 
                controls = new PointerLockControls( camera, document.body );    // Création des axes controls PLC
                var blocker = document.getElementById( 'blocker' );             // Récupération de la div #blocker
                var instructions = document.getElementById( 'instructions' );   // Récupération de la div #instructions
                instructions.addEventListener( 'click', function () {           // Attente de l'évènement clic sur la div #instructions
                    controls.lock();                                            // En attendant, blocage des contrôles
                }, false );                                                     //
                                                                                //
                controls.addEventListener( 'lock', function () {                // Si il y a clic sur la div #instructions plus haut, disparition des div #blocker et #instructions
                    instructions.style.display = 'none';                        // display = none
                    blocker.style.display = 'none';                             // display = none
                } );                                                            //
                controls.addEventListener( 'unlock', function () {              // Si il y a verrouillage des contrôles (on quitte le statut 'unlock') alors apparition des div
                    blocker.style.display = 'block';                            //
                    instructions.style.display = '';                            //
                } );

                // Mapping des touches du clavier pour First Person Control
                var onKeyDown = function ( event ) {
                    switch ( event.keyCode ) {
                        case 38: // up
                        case 90: // w
                            moveForward = true;
                            break;
                        case 37: // left
                        case 81: // a
                            moveLeft = true;
                            break;
                        case 40: // down
                        case 83: // s
                            moveBackward = true;
                            break;
                        case 39: // right
                        case 68: // d
                            moveRight = true;
                            break;
                        case 32: // space
                            if ( canJump === true ) velocity.y += 1750;
                            canJump = false;
                            break;
                    }
                };
                var onKeyUp = function ( event ) {
                    switch ( event.keyCode ) {
                        case 38: // up
                        case 90: // w
                            moveForward = false;
                            break;
                        case 37: // left
                        case 81: // a
                            moveLeft = false;
                            break;
                        case 40: // down
                        case 83: // s
                            moveBackward = false;
                            break;
                        case 39: // right
                        case 68: // d
                            moveRight = false;
                            break;
                    }
                };

                document.addEventListener( 'keydown', onKeyDown, false );
                document.addEventListener( 'keyup', onKeyUp, false );

                raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );  // Création de l'objet Raycaster permettant le travail sur les objets
                                                                                                                // survolés par la souris dans l'espace 3D
                //Création de l'espace 3D (scène) avec ses axes
                scene = new THREE.Scene();
                clock = new THREE.Clock(); //création de l'horloge
                scene.background = new THREE.CubeTextureLoader()
                    .setPath( '../ressources/textures/cube/MilkyWay/' )
                    .load( [ // Load chaque côté du background
                        'dark-s_px.jpg',
                        'dark-s_nx.jpg',
                        'dark-s_py.jpg',
                        'dark-s_ny.jpg',
                        'dark-s_pz.jpg',
                        'dark-s_nz.jpg'
                    ] ); //SKYBOX DU BACKGROUND

                //Lumière ambiente
                ambient = new THREE.AmbientLight( 0xffffff, 0.4 ); // Lumière sans source, éclaire partout
				scene.add( ambient );

                //Chargement des textures
				var texture = new THREE.TextureLoader().load( '../ressources/textures/StoneMarble.jpg' );

                var turretTexture = new THREE.TextureLoader().load( '../ressources/textures/StoneMarble.jpg' );
                
                var wallTexture = new THREE.TextureLoader().load( '../ressources/textures/StoneMarble.jpg' );

                var groundTexture = new THREE.TextureLoader().load( '../ressources/textures/brick_bump.jpg' );
                    groundTexture.wrapS = THREE.RepeatWrapping;
                    groundTexture.wrapT = THREE.RepeatWrapping;
                    groundTexture.repeat.set( 20, 20 );

                var sphereTexture = new THREE.TextureLoader().load( '../ressources/textures/StoneMarble.jpg' );
                    sphereTexture.wrapS = THREE.RepeatWrapping;
                    sphereTexture.wrapT = THREE.RepeatWrapping;
                    sphereTexture.repeat.set( 30, 30 );
                                                     
                //Création des matériaux
                var material = new THREE.MeshPhongMaterial( { map: texture, side: THREE.DoubleSide } );
                var turretMaterial = new THREE.MeshPhongMaterial( { map: turretTexture, side: THREE.DoubleSide } );
                var wallMaterial = new THREE.MeshPhongMaterial( { map: wallTexture, side: THREE.DoubleSide } );
                var groundMaterial = new THREE.MeshPhongMaterial( { map: groundTexture, side: THREE.DoubleSide } );
                var sphereMaterial = new THREE.MeshPhongMaterial( { map: sphereTexture, side: THREE.DoubleSide } );
                                                
                //DÉFINITION DU SOL
				var groundGeometry = new THREE.BoxBufferGeometry( 30000, 1000, 42000 ); //Type/Forme d'objet
                    ground = new THREE.Mesh( groundGeometry, groundMaterial ); //Création de l'objet avec ses matériaux
                    ground.position.y = -ground.geometry.parameters.height/2;
                    ground.receiveShadow = true;
                    ground.wireframe = false;
                    scene.add( ground ); //Ajout de l'objet dans la scene


                //DÉFINITION DES MURS
                var longWallGeometry = new THREE.BoxBufferGeometry( 3000, 3000, 42000 );
                var largeWallGeometry = new THREE.BoxBufferGeometry( 30000, 3000, 3000 );

                    leftWall = new THREE.Mesh( longWallGeometry, wallMaterial );
                    leftWall.receiveShadow = true;
                    leftWall.castShadow = true;
                    scene.add( leftWall );
                    leftWall.position.x = -13500;
                    leftWall.position.y = leftWall.geometry.parameters.height/2;;

                    rightWall = new THREE.Mesh( longWallGeometry, wallMaterial );
                    rightWall.receiveShadow = true;
                    rightWall.castShadow = true;
                    scene.add( rightWall );
                    rightWall.position.x = 13500;
                    rightWall.position.y = rightWall.geometry.parameters.height/2;

                    frontWall = new THREE.Mesh( largeWallGeometry, wallMaterial );
                    frontWall.receiveShadow = true;
                    frontWall.castShadow = true;
                    scene.add( frontWall );
                    frontWall.position.x = 0;
                    frontWall.position.y = frontWall.geometry.parameters.height/2;
                    frontWall.position.z = ground.geometry.parameters.depth/2 - 1250;   

                    backWall = new THREE.Mesh( largeWallGeometry, wallMaterial );
                    backWall.receiveShadow = true;
                    backWall.castShadow = true;
                    scene.add( backWall );
                    backWall.position.x = 0;
                    backWall.position.y = backWall.geometry.parameters.height/2;
                    backWall.position.z = -ground.geometry.parameters.depth/2 + 1250;  


				//DÉFINITION DES TOURELLES DE LA BASE ARRIÈRE
                var turretGeometry = new THREE.BoxBufferGeometry( 3500, 4000, 3500 );
                    // TOURELLE GAUCHE
                    turretBackLeft = new THREE.Mesh( turretGeometry, turretMaterial );
                    turretBackLeft.receiveShadow = true;
                    turretBackLeft.castShadow = true;
                    scene.add( turretBackLeft );
                    turretBackLeft.position.x = -ground.geometry.parameters.width/2 + 1166.667;
                    turretBackLeft.position.z = -ground.geometry.parameters.depth/2 + 5000;    
                    turretBackLeft.position.y = turretBackLeft.geometry.parameters.height/2;

                    // TOURELLE DROITE
                    turretBackRight = new THREE.Mesh( turretGeometry, turretMaterial );
                    turretBackRight.receiveShadow = true;
                    turretBackRight.castShadow = true;
                    scene.add( turretBackRight );
                    turretBackRight.position.x = ground.geometry.parameters.width/2 - 1166.667;
                    turretBackRight.position.z = -ground.geometry.parameters.depth/2 + 5000;    
                    turretBackRight.position.y = turretBackRight.geometry.parameters.height/2;


                //DÉFINITION DES TOURELLES DE LA BASE AVANT
                var turretFrontGeometry = new THREE.BoxBufferGeometry( 5000, 5000, 5000 );
                var miniGeometryTurret = new THREE.BoxBufferGeometry( 1000, 6000, 1000 );
                    // TOURELLE DROITE
                    turretFrontRight = new THREE.Mesh( turretFrontGeometry, turretMaterial );
                    turretFrontRight.receiveShadow = true;
                    turretFrontRight.castShadow = true;
                    scene.add( turretFrontRight );
                    turretFrontRight.position.x = rightWall.position.x - 250;
                    turretFrontRight.position.z = frontWall.position.z;    
                    turretFrontRight.position.y = turretFrontRight.geometry.parameters.height/2;

                    miniTurretFrontLeft_frontRight = new THREE.Mesh( miniGeometryTurret, turretMaterial );
                    miniTurretFrontLeft_frontRight.receiveShadow = true;
                    miniTurretFrontLeft_frontRight.castShadow = true;
                    scene.add ( miniTurretFrontLeft_frontRight );
                    miniTurretFrontLeft_frontRight.position.y = miniTurretFrontLeft_frontRight.geometry.parameters.height/2;
                    miniTurretFrontLeft_frontRight.position.x = turretFrontRight.position.x - (turretFrontRight.geometry.parameters.width/2);
                    miniTurretFrontLeft_frontRight.position.z = turretFrontRight.position.z + (turretFrontRight.geometry.parameters.depth/2);

                    miniTurretFrontRight_frontRight = new THREE.Mesh( miniGeometryTurret, turretMaterial );
                    miniTurretFrontRight_frontRight.receiveShadow = true;
                    miniTurretFrontRight_frontRight.castShadow = true;
                    scene.add ( miniTurretFrontRight_frontRight );
                    miniTurretFrontRight_frontRight.position.y = miniTurretFrontRight_frontRight.geometry.parameters.height/2;
                    miniTurretFrontRight_frontRight.position.x = turretFrontRight.position.x + (turretFrontRight.geometry.parameters.width/2);
                    miniTurretFrontRight_frontRight.position.z = turretFrontRight.position.z + (turretFrontRight.geometry.parameters.depth/2); 

                    miniTurretBackRight_frontRight = new THREE.Mesh( miniGeometryTurret, turretMaterial );
                    miniTurretBackRight_frontRight.receiveShadow = true;
                    miniTurretBackRight_frontRight.castShadow = true;
                    scene.add ( miniTurretBackRight_frontRight );
                    miniTurretBackRight_frontRight.position.y = miniTurretBackRight_frontRight.geometry.parameters.height/2;
                    miniTurretBackRight_frontRight.position.x = turretFrontRight.position.x + (turretFrontRight.geometry.parameters.width/2);
                    miniTurretBackRight_frontRight.position.z = turretFrontRight.position.z - (turretFrontRight.geometry.parameters.depth/2);

                    // TOURELLE GAUCHE
                    turretFrontLeft = new THREE.Mesh( turretFrontGeometry, turretMaterial );
                    turretFrontLeft.receiveShadow = true;
                    turretFrontLeft.castShadow = true;
                    scene.add( turretFrontLeft );
                    turretFrontLeft.position.x = leftWall.position.x - 250;
                    turretFrontLeft.position.z = frontWall.position.z;    
                    turretFrontLeft.position.y = turretFrontLeft.geometry.parameters.height/2;

                    miniTurretFrontLeft_frontLeft = new THREE.Mesh( miniGeometryTurret, turretMaterial );
                    miniTurretFrontLeft_frontLeft.receiveShadow = true;
                    miniTurretFrontLeft_frontLeft.castShadow = true;
                    scene.add ( miniTurretFrontLeft_frontLeft );
                    miniTurretFrontLeft_frontLeft.position.y = miniTurretFrontLeft_frontLeft.geometry.parameters.height/2;
                    miniTurretFrontLeft_frontLeft.position.x = turretFrontLeft.position.x - (turretFrontLeft.geometry.parameters.width/2);
                    miniTurretFrontLeft_frontLeft.position.z = turretFrontLeft.position.z + (turretFrontLeft.geometry.parameters.depth/2);

                    miniTurretFrontRight_frontLeft = new THREE.Mesh( miniGeometryTurret, turretMaterial );
                    miniTurretFrontRight_frontLeft.receiveShadow = true;
                    miniTurretFrontRight_frontLeft.castShadow = true;
                    scene.add ( miniTurretFrontRight_frontLeft );
                    miniTurretFrontRight_frontLeft.position.y = miniTurretFrontRight_frontLeft.geometry.parameters.height/2;
                    miniTurretFrontRight_frontLeft.position.x = turretFrontLeft.position.x + (turretFrontLeft.geometry.parameters.width/2);
                    miniTurretFrontRight_frontLeft.position.z = turretFrontLeft.position.z + (turretFrontLeft.geometry.parameters.depth/2); 

                    miniTurretBackLeft_frontLeft = new THREE.Mesh( miniGeometryTurret, turretMaterial );
                    miniTurretBackLeft_frontLeft.receiveShadow = true;
                    miniTurretBackLeft_frontLeft.castShadow = true;
                    scene.add ( miniTurretBackLeft_frontLeft );
                    miniTurretBackLeft_frontLeft.position.y = miniTurretBackLeft_frontLeft.geometry.parameters.height/2;
                    miniTurretBackLeft_frontLeft.position.x = turretFrontLeft.position.x - (turretFrontLeft.geometry.parameters.width/2);
                    miniTurretBackLeft_frontLeft.position.z = turretFrontLeft.position.z - (turretFrontLeft.geometry.parameters.depth/2);
                     
                
                //DÉFINITION DES BÂTIMENTS
                var mainBuildGeometry = new THREE.BoxBufferGeometry( 27000, 6000, 7000 );       
                var mainBuildFrGeo = new THREE.BoxBufferGeometry( 27000, 3500, 3500 );
                var mainBuildLitFrGeo = new THREE.BoxBufferGeometry( 27000, 2000, 1750 );        
                var mainBuildMidGeo = new THREE.BoxBufferGeometry( 10000, 4500, 6250);


                    mainBuilding = new THREE.Mesh( mainBuildGeometry, turretMaterial );
                    mainBuilding.receiveShadow = true;
                    mainBuilding.castShadow = true;
                    scene.add( mainBuilding );
                    
                    mainBuilding.position.y = mainBuilding.geometry.parameters.height/2;
                    mainBuilding.receiveShadow = true;
                    mainBuilding.castShadow = true;
                    mainBuilding.position.z = -16000;

                    mainBuildingFront = new THREE.Mesh( mainBuildFrGeo, turretMaterial );
                    mainBuildingFront.receiveShadow = true;
                    mainBuildingFront.castShadow = true;
                    scene.add( mainBuildingFront );
                    mainBuildingFront.position.y = mainBuildingFront.geometry.parameters.height/2;
                    mainBuildingFront.position.z = mainBuilding.position.z + (mainBuilding.geometry.parameters.depth/2) + (mainBuildingFront.geometry.parameters.depth/2);

                    mainBuildingLittleFront = new THREE.Mesh( mainBuildLitFrGeo, wallMaterial );
                    mainBuildingLittleFront.receiveShadow = true;
                    mainBuildingLittleFront.castShadow = true;
                    scene.add( mainBuildingLittleFront );
                    mainBuildingLittleFront.position.y = mainBuildingLittleFront.geometry.parameters.height/2;
                    mainBuildingLittleFront.position.z = mainBuildingFront.position.z + (mainBuildingFront.geometry.parameters.depth/2) + (mainBuildingLittleFront.geometry.parameters.depth/2);
                    
                    mainBuildingMiddle = new THREE.Mesh( mainBuildMidGeo, turretMaterial );
                    mainBuildingMiddle.receiveShadow = true;
                    mainBuildingMiddle.castShadow = true;
                    scene.add( mainBuildingMiddle );
                    mainBuildingMiddle.position.y = mainBuildingMiddle.geometry.parameters.height/2;
                    mainBuildingMiddle.position.z = mainBuildingFront.position.z + (mainBuildingLittleFront.geometry.parameters.depth/2) + 500;

                    //Mirroir devant le mainBuildingMiddle
                    var mirrorGeo = new THREE.PlaneBufferGeometry( mainBuildingMiddle.geometry.parameters.width, mainBuildingMiddle.geometry.parameters.height );
                    var verticalMirror = new Reflector( mirrorGeo, {
                        clipBias: 0.003, //Capacité de reflexion du mirroir
                        textureWidth: window.innerWidth * window.devicePixelRatio, //Qualité de texture du mirroir
                        textureHeight: window.innerHeight * window.devicePixelRatio,
                        color: 0x889999
                    } );
                        verticalMirror.position.y = mainBuildingMiddle.position.y;
                        verticalMirror.position.x = mainBuildingMiddle.position.x;
                        verticalMirror.position.z = mainBuildingMiddle.position.z + mainBuildingMiddle.geometry.parameters.depth/2 + 100;
                        verticalMirror.visible = false; //pour rendre invisible l'objet
                    scene.add( verticalMirror );

                    //Ajout des miniTourelle sur les buildings
                    miniTurretMainBuilding_frontLeft = new THREE.Mesh( miniGeometryTurret, turretMaterial );
                    miniTurretMainBuilding_frontLeft.receiveShadow = true;
                    miniTurretMainBuilding_frontLeft.castShadow = true;
                    scene.add( miniTurretMainBuilding_frontLeft );
                    miniTurretMainBuilding_frontLeft.position.y = (miniTurretMainBuilding_frontLeft.geometry.parameters.height/2);
                    miniTurretMainBuilding_frontLeft.position.x = mainBuildingMiddle.position.x - (mainBuildingMiddle.geometry.parameters.width/2);
                    miniTurretMainBuilding_frontLeft.position.z = mainBuildingMiddle.position.z + (mainBuildingMiddle.geometry.parameters.depth/2);

                    miniTurretMainBuilding_frontRight = new THREE.Mesh( miniGeometryTurret, turretMaterial );
                    miniTurretMainBuilding_frontRight.receiveShadow = true;
                    miniTurretMainBuilding_frontRight.castShadow = true;
                    scene.add( miniTurretMainBuilding_frontRight );
                    miniTurretMainBuilding_frontRight.position.y = (miniTurretMainBuilding_frontRight.geometry.parameters.height/2);
                    miniTurretMainBuilding_frontRight.position.x = mainBuildingMiddle.position.x + (mainBuildingMiddle.geometry.parameters.width/2);
                    miniTurretMainBuilding_frontRight.position.z = mainBuildingMiddle.position.z + (mainBuildingMiddle.geometry.parameters.depth/2);

                    //DÉFINITION DE L'ENTRÉ
                    var gateGeometry = new THREE.BoxBufferGeometry( 10000, 4000, 5000 );
                    var miniGeometry = new THREE.BoxBufferGeometry( 1000, 5000, 1000 );

                    frontGateBig = new THREE.Mesh( turretFrontGeometry, turretMaterial );
                    scene.add( frontGateBig );
                    frontGateBig.position.z = frontWall.position.z + 500;    
                    frontGateBig.position.y = frontGateBig.geometry.parameters.height/2;

                    frontGateSmall = new THREE.Mesh ( gateGeometry, turretMaterial );
                    scene.add( frontGateSmall );
                    frontGateSmall.position.y = frontGateSmall.geometry.parameters.height/2;
                    frontGateSmall.position.z = frontGateBig.position.z - 500;

                    //Ajout des miniTourelle sur la porte
                    miniTurretFrontLeft = new THREE.Mesh ( miniGeometry, turretMaterial );
                    scene.add ( miniTurretFrontLeft );
                    miniTurretFrontLeft.position.y = miniTurretFrontLeft.geometry.parameters.height/2;
                    miniTurretFrontLeft.position.z = frontGateSmall.position.z + (frontGateSmall.geometry.parameters.depth/2);
                    miniTurretFrontLeft.position.x = frontGateSmall.position.x - (frontGateSmall.geometry.parameters.width/2);

                    miniTurretFrontRight = new THREE.Mesh ( miniGeometry, turretMaterial );
                    scene.add ( miniTurretFrontRight );
                    miniTurretFrontRight.position.y = miniTurretFrontRight.geometry.parameters.height/2;
                    miniTurretFrontRight.position.z = frontGateSmall.position.z + (frontGateSmall.geometry.parameters.depth/2);
                    miniTurretFrontRight.position.x = frontGateSmall.position.x + (frontGateSmall.geometry.parameters.width/2);

                    miniTurretBackLeft = new THREE.Mesh ( miniGeometry, turretMaterial );
                    scene.add ( miniTurretBackLeft );
                    miniTurretBackLeft.position.y = miniTurretBackLeft.geometry.parameters.height/2;
                    miniTurretBackLeft.position.z = frontGateSmall.position.z - (frontGateSmall.geometry.parameters.depth/2);
                    miniTurretBackLeft.position.x = frontGateSmall.position.x - (frontGateSmall.geometry.parameters.width/2);

                    miniTurretBackRight = new THREE.Mesh ( miniGeometry, turretMaterial );
                    scene.add ( miniTurretBackRight );
                    miniTurretBackRight.position.y = miniTurretBackRight.geometry.parameters.height/2;
                    miniTurretBackRight.position.z = frontGateSmall.position.z - (frontGateSmall.geometry.parameters.depth/2);
                    miniTurretBackRight.position.x = frontGateSmall.position.x + (frontGateSmall.geometry.parameters.width/2);

                    //Lumière spotLightMainBuildingMiddle
                    spotLightMainBuildingMiddle = new THREE.SpotLight( 0xffffff, 2 );
                    spotLightMainBuildingMiddle.position.set(mainBuildingMiddle.position.x, mainBuildingMiddle.position.y + mainBuildingMiddle.geometry.parameters.height/2, mainBuildingMiddle.position.z + mainBuildingMiddle.geometry.parameters.depth/2);
                    spotLightMainBuildingMiddle.angle = 0.4; //Angle de la lumière
                    spotLightMainBuildingMiddle.penumbra = 0.5;
                    spotLightMainBuildingMiddle.decay = 1; // Quantité d'ombre perdue selon la distance 
                    spotLightMainBuildingMiddle.focus = 1;
                    spotLightMainBuildingMiddle.distance = 40000;
                    spotLightMainBuildingMiddle.intensity = 1.1;                     

                    spotLightMainBuildingMiddle.castShadow = true;
                    spotLightMainBuildingMiddle.shadow.mapSize.width = 512; // Qualité de l'ombre
                    spotLightMainBuildingMiddle.shadow.mapSize.height = 512;
                    spotLightMainBuildingMiddle.shadow.camera.near = 1;
                    spotLightMainBuildingMiddle.shadow.camera.far = 100000;
                    spotLightMainBuildingMiddle.shadow.focus = 1;
                    spotLightMainBuildingMiddle.visible = false;
                    scene.add( spotLightMainBuildingMiddle );

                    // lightHelper = new THREE.SpotLightHelper( spotLightMainBuildingMiddle );
                    // scene.add( lightHelper );
                
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DEBUT DOMES @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

                // Fonction de création de dome
                function addDome(build, size, gapx, gapz){
                    var dome_sphere = new THREE.SphereBufferGeometry( size, 32, 32);
                    var dome_cylindre = new THREE.CylinderGeometry( size, size, size, 32 );
                    var dome_octogone = new THREE.CylinderGeometry( size+100, size+200, 500, 32 );
                    
                        octogone = new THREE.Mesh( dome_octogone,material);
                        octogone.position.y = build.position.y + (build.geometry.parameters.height/2) + (octogone.geometry.parameters.height/2);
                        octogone.position.x = build.position.x + gapx;
                        octogone.position.z = build.position.z + gapz;
                        octogone.castShadow = true;
                        octogone.receiveShadow = true;
                        scene.add(octogone);

                        cylindre = new THREE.Mesh( dome_cylindre,material);
                        cylindre.position.y = octogone.position.y + cylindre.geometry.parameters.height/2;
                        cylindre.position.x = octogone.position.x;
                        cylindre.position.z = octogone.position.z;
                        cylindre.castShadow = true;
                        cylindre.receiveShadow = true;
                        scene.add(cylindre);

                        sphere = new THREE.Mesh( dome_sphere, sphereMaterial);
                        sphere.position.y = cylindre.position.y + sphere.geometry.parameters.radius;
                        sphere.position.x = cylindre.position.x;
                        sphere.position.z = cylindre.position.z;
                        sphere.castShadow = true;
                        sphere.receiveShadow = true;
                        scene.add(sphere);
                }

                // FONCTION POUR POSITIONNER LES DOMES SUR LA MOSQUÉE (2 boucles for pour 4 domes)
                function loopDomes(build, size){

                    // Condition de vérification si la largeur du bâtiment > profondeur de celui-ci
                    if(build.geometry.parameters.width > build.geometry.parameters.depth){
                        // Placement des 'gap' en horizontal entre les deux premiers domes et le batiment associé
                        if(build == frontWall || build == mainBuildingLittleFront){
                            var gapx = build.geometry.parameters.width/4.25;
                        } else {
                            var gapx = build.geometry.parameters.width/9;
                        }
                           
                        // Placement des domes à l'aide de boucles   
                        var gapz = 0;
                        for(let i = 0; i < 2; i++){ // On veut parcourir cette boucle deux fois, pour créer deux objets
                            addDome(build, size, gapx, gapz);
                            gapx = gapx*(-1); // Si le gap est de 4.25, il devient -4.25, cela permet de créer un deuxième dôme symétrique au premier par rapport au bâtiment associé
                        }

                        // Placement des 'gap' en horizontal entre les deux autres dômes et le bâtiment associé
                        if(build == frontWall || build == mainBuildingLittleFront){
                            gapx = build.geometry.parameters.width/3.250;
                        } else {
                            gapx = build.geometry.parameters.width/3;
                        }

                        // Placement des domes à l'aide de boucles   
                        for(let i = 0; i < 2; i++){
                            addDome(build, size, gapx, gapz);
                            gapx = gapx*(-1);
                        }

                    } else { // Concerne les batiments qui ont un width < à leur depth, donc les batiments sur les côtés
                        var gapx = 0;
                        var gapz = build.geometry.parameters.depth/9; 
                        for(let i = 0; i < 2; i++){ // Création des deux premiers domes, ceux les plus au centre du wall
                            addDome(build, size, gapx, gapz);
                            gapz = gapz*(-1);
                        }

                        gapz = build.geometry.parameters.depth/3;

                        for(let i = 0; i < 2; i++){ // Création des deux derniers domes, ceux les plus aux extrémitées
                            addDome(build, size, gapx, gapz);
                            gapz = gapz*(-1);
                        }
                    }
                    
                }

                //APPEL DE LA FONCTION loopDomes
                //Les mini dômes
                loopDomes(rightWall, 700);
                loopDomes(leftWall, 700);
                loopDomes(frontWall, 700);
                loopDomes(mainBuildingLittleFront, 700);
                loopDomes(backWall, 700);
                                
                //Les dômes de la Building
                addDome(mainBuilding, 3250, 0, 0);
                addDome(mainBuilding, 2000, -7000, 0);
                addDome(mainBuilding, 2000, 7000, 0);
                
                //Les dômes des portes
                addDome(mainBuildingMiddle, 1200, 0, 0);
                addDome(frontGateBig, 1000, 0, 0);

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ FIN DOMES @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DEBUT MINARET @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

                //FONCTION MINARETS
                function addMinaret(turret, mainBuild, lightStatus){
                    var baseMinaretGeo = new THREE.BoxBufferGeometry( 200*(6000/700), 12000, 200*(6000/700) );
                    var decoMinaretGeo = new THREE.ConeBufferGeometry( 150*(6000/700), 200*(6000/700), 4 );
                    var linkGeo = new THREE.CylinderGeometry( 100*(6000/700), 140*(6000/700), 100*(6000/700), 4, 1 );
                    var geoLC = new THREE.CylinderBufferGeometry( 100*(6000/700), 100*(6000/700), 400*(6000/700), 8 );
                    var balconyGeoLB = new THREE.CylinderGeometry( 180*(6000/700), 100*(6000/700),50*(6000/700), 600, 1 );
                    var balconyGeoLT = new THREE.CylinderBufferGeometry( 180*(6000/700), 180*(6000/700), 30*(6000/700), 1000 );
                    var geoMC = new THREE.CylinderBufferGeometry( 50*(6000/700), 100*(6000/700), 400*(6000/700), 1000 );
                    var balconyGeoMB = new THREE.CylinderGeometry( 120*(6000/700), 80*(6000/700),50*(6000/700), 600, 1 );
                    var balconyGeoMT = new THREE.CylinderBufferGeometry( 120*(6000/700), 120*(6000/700), 30*(6000/700), 1000 );
                    var balconyGeoHB = new THREE.CylinderGeometry( 80*(6000/700), 50*(6000/700), 50*(6000/700), 600, 1 );
                    var balconyGeoHT = new THREE.CylinderBufferGeometry( 80*(6000/700), 80*(6000/700), 30*(6000/700), 1000 );
                    var spikeBottomGeo = new THREE.SphereBufferGeometry( 50*(6000/700), 32, 32 );
                    var spikeGeo = new THREE.CylinderBufferGeometry( 10*(6000/700), 30*(6000/700), 300*(6000/700), 1000 );
                    var spikeCircleGeo = new THREE.CylinderBufferGeometry( 30*(6000/700), 30*(6000/700), 10*(6000/700), 1000 );
                    var spikeTopGeo = new THREE.SphereBufferGeometry( 30*(6000/700), 30*(6000/700), 10 );
                    var moonGeo = new THREE.RingGeometry( 20*(6000/700), 30*(6000/700), 3000 );

                        //  BASE
                        minaret_Base = new THREE.Mesh( baseMinaretGeo, material ) ;//Création de l'objet avec ses matériaux
                        minaret_Base.position.y = minaret_Base.geometry.parameters.height/2;
                    
                        //POSITIONNEMENT DES MINARETS SUIVANT LES X
                        if (turret.position.x > 0){
                            minaret_Base.position.x = turret.position.x - (turret.geometry.parameters.width/1.4);
                        } else {
                            minaret_Base.position.x = turret.position.x + (turret.geometry.parameters.width/1.4);
                        }
                        
                        if(mainBuild != null){ // POSITIONEMENT DES MINARETS LIES AU MAIN BUILD ( DONC LES BACK ) SUR LES Z
                            minaret_Base.position.z = mainBuild.position.z + minaret_Base.geometry.parameters.depth;
                        } else { // POSITIONNEMENT DES MINARETS NON LIES AU MAIN BUILD ( DONC LES FRONT ) SUR LES Z
                                minaret_Base.position.z = turret.position.z - (turret.geometry.parameters.depth/2);                        
                        }

                        minaret_Base.castShadow = true;
                        scene.add(minaret_Base ); //Ajout de l'objet dans la scene

                        minaret_deco1Base = new THREE.Mesh( decoMinaretGeo, material );
                        minaret_deco1Base.position.y = minaret_Base.position.y + minaret_deco1Base.geometry.parameters.height/2;
                        minaret_deco1Base.position.z = minaret_Base.position.z;
                        minaret_deco1Base.position.x = minaret_Base.position.x;
                        minaret_deco1Base.castShadow = true;
                        scene.add(minaret_deco1Base );
                        
                        minaret_deco2Base = new THREE.Mesh( decoMinaretGeo, material );
                        minaret_deco2Base.position.y = minaret_Base.position.y + minaret_deco2Base.geometry.parameters.height*2;
                        minaret_deco2Base.position.z = minaret_Base.position.z;
                        minaret_deco2Base.position.x = minaret_Base.position.x;
                        minaret_deco2Base.castShadow = true;
                        scene.add(minaret_deco2Base );

                        minaret_BaseLinkOcto = new THREE.Mesh(linkGeo, material);
                        minaret_BaseLinkOcto.position.y = minaret_Base.position.y + minaret_Base.geometry.parameters.height/2 + minaret_BaseLinkOcto.geometry.parameters.height/2;;
                        minaret_BaseLinkOcto.rotation.y = Math.PI / 4;
                        minaret_BaseLinkOcto.position.z = minaret_Base.position.z;
                        minaret_BaseLinkOcto.position.x = minaret_Base.position.x;
                        minaret_BaseLinkOcto.castShadow = true;
                        scene.add(minaret_BaseLinkOcto);
                    
                        //  TRONC DU BAS
                        minaret_LowerCylinder = new THREE.Mesh( geoLC, material );
                        minaret_LowerCylinder.position.y = minaret_BaseLinkOcto.position.y + minaret_BaseLinkOcto.geometry.parameters.height/2 + minaret_LowerCylinder.geometry.parameters.height/2;
                        minaret_LowerCylinder.position.z = minaret_Base.position.z;
                        minaret_LowerCylinder.position.x = minaret_Base.position.x;                
                        minaret_LowerCylinder.castShadow = true;
                        scene.add(minaret_LowerCylinder );

                        minaret_LowerBalconyBottom = new THREE.Mesh(balconyGeoLB, material);
                        minaret_LowerBalconyBottom.position.y = minaret_LowerCylinder.position.y + minaret_LowerCylinder.geometry.parameters.height/2 + minaret_LowerBalconyBottom.geometry.parameters.height/2;
                        minaret_LowerBalconyBottom.rotation.y = Math.PI / 4;
                        minaret_LowerBalconyBottom.position.z = minaret_Base.position.z;
                        minaret_LowerBalconyBottom.position.x = minaret_Base.position.x;
                        minaret_LowerBalconyBottom.castShadow = true;
                        scene.add(minaret_LowerBalconyBottom);

                        minaret_LowerBalconyTop = new THREE.Mesh( balconyGeoLT, material );
                        minaret_LowerBalconyTop.position.y = minaret_LowerBalconyBottom.position.y + minaret_LowerBalconyBottom.geometry.parameters.height/2 + minaret_LowerBalconyTop.geometry.parameters.height/2;
                        minaret_LowerBalconyTop.position.z = minaret_Base.position.z;
                        minaret_LowerBalconyTop.position.x = minaret_Base.position.x;
                        minaret_LowerBalconyTop.castShadow = true;
                        scene.add(minaret_LowerBalconyTop );

                        //LUMIÈRE
                        //Ajout d'une lumière sur un balcon du minaret
                        if (lightStatus == 'on'){
                            var gap;
                            spotLight = new THREE.SpotLight( 0xffffff, 2 );
                            if (turret.position.z < 0){
                                gap = 1500; // Pour éviter que la light soit bloqué dans l'objet et ne fasse pas de lumière
                            } else {
                                gap = -1500;
                            }
                            spotLight.position.set( minaret_LowerBalconyBottom.position.x, minaret_LowerBalconyBottom.position.y, minaret_LowerBalconyBottom.position.z + gap);
                            spotLight.angle = 0.4;
                            spotLight.penumbra = 0.5;
                            spotLight.decay = 1;
                            spotLight.focus = 1;
                            spotLight.distance = 40000;
                            spotLight.intensity = 1.1;

                            //Positionnement de la cible de la light selon son positionnement, la cible doit toujours être en diagonale
                            if(mainBuild == null){
                                if(turret.position.x > 0){
                                    spotLight.target = turretBackLeft;
                                } else {
                                    spotLight.target = turretBackRight;
                                }
                            } else {
                                if(turret.position.x > 0){
                                    spotLight.target = turretFrontRight;
                                } else {
                                    spotLight.target = turretFrontLeft;
                                }
                            }

                            spotLight.castShadow = true;
                            spotLight.shadow.mapSize.width = 512;
                            spotLight.shadow.mapSize.height = 512;
                            spotLight.shadow.camera.near = 1;
                            spotLight.shadow.camera.far = 100000;
                            spotLight.shadow.focus = 1;
                            scene.add( spotLight );

                            // lightHelper = new THREE.SpotLightHelper( spotLight );
                            // scene.add( lightHelper );
                        }
                        
                        //  TRONC DU HAUT
                        minaret_MiddleCylinder = new THREE.Mesh( geoMC, material );
                        minaret_MiddleCylinder.position.y = minaret_LowerBalconyTop.position.y + minaret_LowerBalconyTop.geometry.parameters.height/2 + minaret_MiddleCylinder.geometry.parameters.height/2;
                        minaret_MiddleCylinder.position.z = minaret_Base.position.z;
                        minaret_MiddleCylinder.position.x = minaret_Base.position.x;
                        minaret_MiddleCylinder.castShadow = true;
                        scene.add(minaret_MiddleCylinder );

                        minaret_MiddleBalconyBottom = new THREE.Mesh(balconyGeoMB, material);
                        minaret_MiddleBalconyBottom.position.y = minaret_MiddleCylinder.position.y + minaret_MiddleCylinder.geometry.parameters.height/2 + minaret_MiddleBalconyBottom.geometry.parameters.height/2;
                        minaret_MiddleBalconyBottom.rotation.y = Math.PI / 4;
                        minaret_MiddleBalconyBottom.position.z = minaret_Base.position.z;
                        minaret_MiddleBalconyBottom.position.x = minaret_Base.position.x;
                        minaret_MiddleBalconyBottom.castShadow = true;
                        scene.add(minaret_MiddleBalconyBottom);

                        minaret_MiddleBalconyTop = new THREE.Mesh( balconyGeoMT, material );
                        minaret_MiddleBalconyTop.position.y = minaret_MiddleBalconyBottom.position.y + minaret_MiddleBalconyBottom.geometry.parameters.height/2 + minaret_MiddleBalconyTop.geometry.parameters.height/2;
                        minaret_MiddleBalconyTop.position.z = minaret_Base.position.z;
                        minaret_MiddleBalconyTop.position.x = minaret_Base.position.x;
                        minaret_MiddleBalconyTop.castShadow = true;
                        scene.add(minaret_MiddleBalconyTop );

                        minaret_HigherBalconyBottom = new THREE.Mesh(balconyGeoHB, material);
                        minaret_HigherBalconyBottom.position.y = minaret_MiddleBalconyTop.position.y + minaret_MiddleBalconyTop.geometry.parameters.height/2 + minaret_HigherBalconyBottom.geometry.parameters.height/2;
                        minaret_HigherBalconyBottom.rotation.y = Math.PI / 4;
                        minaret_HigherBalconyBottom.position.z = minaret_Base.position.z;
                        minaret_HigherBalconyBottom.position.x = minaret_Base.position.x;
                        minaret_HigherBalconyBottom.castShadow = true;
                        scene.add(minaret_HigherBalconyBottom);

                        minaret_HigherBalconyTop = new THREE.Mesh( balconyGeoHT, material );
                        minaret_HigherBalconyTop.position.y = minaret_HigherBalconyBottom.position.y + minaret_HigherBalconyBottom.geometry.parameters.height/2 + minaret_HigherBalconyTop.geometry.parameters.height/2;
                        minaret_HigherBalconyTop.position.z = minaret_Base.position.z;
                        minaret_HigherBalconyTop.position.x = minaret_Base.position.x;
                        minaret_HigherBalconyTop.castShadow = true;
                        scene.add(minaret_HigherBalconyTop );

                        //  POINTE DU MINARET
                        minaret_SpikeBottom = new THREE.Mesh( spikeBottomGeo, material );
                        minaret_SpikeBottom.position.y = minaret_HigherBalconyTop.position.y + minaret_HigherBalconyTop.geometry.parameters.height/2 + minaret_SpikeBottom.geometry.parameters.radius;
                        minaret_SpikeBottom.position.z = minaret_Base.position.z;
                        minaret_SpikeBottom.position.x = minaret_Base.position.x;
                        minaret_SpikeBottom.castShadow = true;
                        scene.add(minaret_SpikeBottom );

                        minaret_Spike = new THREE.Mesh( spikeGeo, material );
                        minaret_Spike.position.y = minaret_SpikeBottom.position.y + minaret_SpikeBottom.geometry.parameters.radius + minaret_Spike.geometry.parameters.height/2;
                        minaret_Spike.position.z = minaret_Base.position.z;
                        minaret_Spike.position.x = minaret_Base.position.x;
                        minaret_Spike.castShadow = true;
                        scene.add(minaret_Spike);

                        minaret_SpikeCircle1 = new THREE.Mesh( spikeCircleGeo, material );
                        minaret_SpikeCircle1.position.y = minaret_Spike.position.y + minaret_Spike.geometry.parameters.height/2 + minaret_SpikeCircle1.geometry.parameters.height/2;
                        minaret_SpikeCircle1.position.z = minaret_Base.position.z;
                        minaret_SpikeCircle1.position.x = minaret_Base.position.x;
                        minaret_SpikeCircle1.castShadow = true;
                        scene.add(minaret_SpikeCircle1 );

                        minaret_SpikeCircle2 = new THREE.Mesh( spikeCircleGeo, material );
                        minaret_SpikeCircle2.position.y = minaret_SpikeCircle1.position.y + minaret_SpikeCircle1.geometry.parameters.height/2 + minaret_SpikeCircle2.geometry.parameters.height/2;
                        minaret_SpikeCircle2.position.z = minaret_Base.position.z;
                        minaret_SpikeCircle2.position.x = minaret_Base.position.x;
                        minaret_SpikeCircle2.castShadow = true;
                        scene.add(minaret_SpikeCircle2 );

                        minaret_SpikeTop = new THREE.Mesh( spikeTopGeo, material );
                        minaret_SpikeTop.position.y = minaret_SpikeCircle2.position.y + minaret_SpikeCircle2.geometry.parameters.height/2 + minaret_SpikeTop.geometry.parameters.radius;
                        minaret_SpikeTop.position.z = minaret_Base.position.z;
                        minaret_SpikeTop.position.x = minaret_Base.position.x;
                        minaret_SpikeTop.castShadow = true;
                        scene.add(minaret_SpikeTop );

                        minaret_Moon = new THREE.Mesh( moonGeo, material );
                        minaret_Moon.position.y = minaret_SpikeTop.position.y + minaret_SpikeTop.geometry.parameters.radius;
                        minaret_Moon.position.z = minaret_Base.position.z;
                        minaret_Moon.position.x = minaret_Base.position.x;
                        minaret_Moon.castShadow = true;
                        scene.add(minaret_Moon );
                
                }

                //APPEL DE LA FONCTION addMinaret
                addMinaret(turretFrontLeft, null, 'on');
                addMinaret(turretBackLeft, mainBuildingLittleFront, 'on');
                addMinaret(turretFrontRight, null, 'on');
                addMinaret(turretBackRight, mainBuildingLittleFront, 'on');

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ FIN MINARET @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ OBJETS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                //DEBUT AJOUT Stormtrooper
                const colladaLoader = new ColladaLoader();
                colladaLoader.load( './models/collada/stormtrooper/stormtrooper.dae', function ( collada ) {
                    const animations = collada.animations; //range les animations dans variable
                    stormtrooper = collada.scene; //range la scène dans var
                    stormtrooper.traverse( function ( node ) { // Execute le rappel sur l'objet et tous les descendants

                        if ( node.isSkinnedMesh ) { // Si l'objet a un skelette, autrement dit on vérifie si il est articulé.

                            node.frustumCulled = false; // Check tous les frames de l'objet avant de le render

                            node.castShadow = true; // emet une ombre 
                            node.receiveShadow = true; // recoit les ombres
                        }
                    } );
                    //Mixer qui marche comme un player d'animation comme un player video
                    var mixer = new THREE.AnimationMixer(stormtrooper);
                    mixer.clipAction(animations[0]).play();//Animation du collada (danse)
                    stormtrooper.scale.set(190,190,190); //Mis à l'échelle du collada
                    //stormtrooper.position.set(posxyz[0],posxyz[1],posxyz[2]); //Position du collada
                    stormtrooper.visible = false; // le stormtrooper est de base invisible
                    scene.add( stormtrooper );
                    objs.push({stormtrooper, mixer});
                    spotLightMainBuildingMiddle.target = stormtrooper; // Le spotlight précédemment créé vise le personnage 
                } );
                //FIN AJOUT Stormtrooper

                //DEBUT AJOUT Mouse
				const fbxLoader = new FBXLoader();
				fbxLoader.load( './models/fbx/Dancing_Twerk.fbx', function ( fbx ) {
                    const animations = fbx.animations; //range les animations dans variable
                    mouse = fbx; //range la scène dans var
                    mouse.traverse( function ( node ) { // Execute le rappel sur l'objet et tous les descendants

                        if ( node.isSkinnedMesh ) { // Si l'objet a un skelette, autrement dit on vérifie si il est articulé.

                            node.frustumCulled = false; // Check tous les frames de l'objet avant de le render

                            node.castShadow = true; // emet une ombre 
                            node.receiveShadow = true; // recoit les ombres
                        }
                    } );
                    var mixer = new THREE.AnimationMixer(mouse);
                    mixer.clipAction(animations[0]).play();//Animation du fbx (danse)
                    mouse.scale.set(5,5,5);
                    mouse.position.set(0,0,-600);
                    mouse.rotation.y = Math.PI;
                    mouse.visible = false;
                    mouse.add(voice);
                    scene.add( mouse );
                    objs.push({mouse, mixer});
				} );
                //FIN AJOUT Mouse

                //DEBUT AJOUT FBX
                    createFbx('source/alien', [15,15,15], [2000,0,-600], -Math.PI/2);
                    createFbx('source/eve', [100,100,100], [1000,1000,-600], Math.PI/2);
                    createFbx('source/spaceship', [90,90,90], [4000,1000,8000], Math.PI);
                    createFbx('source/trump', [1000,1000,1000], [-6000,0,-600], Math.PI/2);
                    createFbx('source/shrek', [0.2,0.2,0.2], [-4000,0, 3000], -Math.PI/2);
                    createFbx('source/hitler', [0.2,0.2,0.2], [-4000,0, -600], -Math.PI/2);
                //FIN AJOUT FBX
                //DEBUT AJOUT FBX
                    //createFbx('Dancing_Twerk', [100,100,100], [0,0,-600]);
                //FIN AJOUT FBX

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ SON @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                // Création de l'audio
                listener = new THREE.AudioListener();
                camera.add( listener );

                globalAudio = new THREE.Audio( listener ); // Source audio globale

                audioLoader = new THREE.AudioLoader(); // Chargement d'un audio et mise en place dans le buffer de l'objet Audio
                audioLoader.load( '../src/sounds/minecraft.mp3', function( buffer ) {
                    globalAudio.setBuffer( buffer );
                    globalAudio.setLoop( true );
                    globalAudio.setVolume( 0.025 );
                    globalAudio.play();
                });

                // Ajout de l'audio positionnel référencé sur la souris animée
                voice = new THREE.PositionalAudio( listener );
                
                // Téléchargement de la musique et ajustements              
                audioLoader = new THREE.AudioLoader(); // Chargement d'un audio et mise en place dans le buffer de l'objet Audio
                audioLoader.load( '../src/sounds/body.mp3', function( buffer ) {
                    voice.setBuffer( buffer );
                    voice.setLoop( true );
                    voice.setVolume( 100 );
                    voice.setRefDistance(0.10);
                    //voice.play();
                });


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ GUI @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                //FONCTION DU GUI
                function displaygui() {
                    var gui = new GUI;
                    //Ajout des différents paramètres possibles pour gui
                    var parameters = { // Lorsque l'on charge la page, les 4 paramètres du futur menu "Party" du GUI sont désactivés
                        stormtrooperSwitch: false,
                        mouseSwitch: false,
                        lightSwitch: false,
                        mirrorSwitch: false,
                        music: "",
			            volume: 0.025
                    };

                    var sounds = gui.addFolder('Music scene'); //Dossier

                    //ajout du paramètre "volume" dans le dossier sounds et le nommer
                    var soundVolume = sounds.add(parameters, 'volume').min(0).max(1).step(0.005).name('Volume');
                    //Ajout de la fonction d'état du paramètre "volume"
                    soundVolume.onChange(function(changed){
                        globalAudio.setVolume(changed);

                    });

                    //ajout du paramètre "music" dans le dossier sounds et le nommer
                    var song = sounds.add(parameters, 'music', ['../src/sounds/body.mp3','../src/sounds/work.mp3']).name("Song")
                    song.onChange(function(changed){
                        if(mouse.visible == true){
                            voice.stop();
                        }
                        audioLoader.load( changed, function( buffer ) {
                        voice.setBuffer( buffer );
                        voice.setLoop( true );
                        voice.setVolume( 100 );
                        if(mouse.visible == true){
                            voice.play();
                        }

                        
                        })
                    });

                    var party = gui.addFolder('Party Control'); //Dossier

                    //ajout du paramètre "stormtrooperSwitch" dans le dossier party et le nommer
                    var stormControl = party.add(parameters, 'stormtrooperSwitch').name('Stormtrooper');

                    //Ajout de la fonction d'état du paramètre "stormtrooperSwitch"
                    stormControl.onChange(function(changed){
                        stormtrooper.visible = changed; // Le personnage est désormais visible
                    });

                    //ajout du paramètre "mouseSwitch" dans le dossier party et le nommer
                    var mouseControl = party.add(parameters, 'mouseSwitch').name('Mouse');

                    //Ajout de la fonction d'état du paramètre "mouseSwitch"
                    mouseControl.onChange(function(changed){
                        mouse.visible = changed;// Le personnage est désormais visible
                        if(changed){
                            voice.play();
                        }else{
                            voice.stop();
                        } 
                    });

                    //ajout du paramètre "mirrorSwitch" dans le dossier party et le nommer
                    var mirrorControl = party.add(parameters, 'mirrorSwitch').name('Mirror');

                    //Ajout de la fonction d'état du paramètre "mirrorSwitch"
                    mirrorControl.onChange(function(changed){
                        verticalMirror.visible = changed;
                    });

                    var lights = gui.addFolder('Lights Control'); //Dossier

                    //ajout du paramètre "lightSwitch" dans le dossier lights et le nommer
                    var lightControl = lights.add(parameters, 'lightSwitch').name('SpotLight');

                    //Ajout de la fonction d'état du paramètre "lightSwitch"
                    lightControl.onChange(function(changed){
                        spotLightMainBuildingMiddle.visible = changed;
                    });
                    
                }

                //Appel de la fonction displaygui
                displaygui();

                //
                
                renderer = new THREE.WebGLRenderer( { antialias: true } ); //Moteur graphique (anti-aliasing: pour lisser le graphisme)
				renderer.setPixelRatio( window.devicePixelRatio ); //Respect du ration des pixels
				renderer.setSize( window.innerWidth, window.innerHeight ); //Taille du rendu
				document.body.appendChild( renderer.domElement ); //Attachement du rendu à l'html

                renderer.shadowMap.enabled = true; //Autoriser les ombres dans le moteur
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; //Type d'ombre soft
                
                // controls = new OrbitControls( camera, renderer.domElement );
                // controls.update();

				window.addEventListener( 'resize', onWindowResize, false ); //Adaptation au changement de taille de la fenêtre avec appel de sa fonction ↩️
			}


			function onWindowResize() {
                //Adaptation au changement de taille de la fenêtre
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
                
				renderer.setSize( window.innerWidth, window.innerHeight ); //Taille du rendu
            }
            
            function createCollada(name, scalexyz, posxyz){
                //DEBUT AJOUT COLLADA
                const colladaLoader = new ColladaLoader();
                var object;
                colladaLoader.load( './models/collada/' + name + '.dae', function ( collada ) {
                    const animations = collada.animations; //range les animations dans variable
                    object = collada.scene; //range la scène dans var
                    object.traverse( function ( node ) { // Execute le rappel sur l'objet et tous les descendants

                        if ( node.isSkinnedMesh ) { // Si l'objet a un skelette, autrement dit on vérifie si il est articulé.

                            node.frustumCulled = false; // Check tous les frames de l'objet avant de le render

                            node.castShadow = true; // emet une ombre 
                            node.receiveShadow = true; // recoit les ombres
                        }
                    } );
                    //Mixer qui marche comme un player d'animation comme un player video
                    var mixer = new THREE.AnimationMixer(object);
                    mixer.clipAction(animations[0]).play();//Animation du collada
                    object.scale.set(scalexyz[0],scalexyz[1],scalexyz[2]); //Mis à l'échelle du collada
                    object.position.set(posxyz[0],posxyz[1],posxyz[2]); //Position du collada
                    scene.add( object );
                    objs.push({object, mixer});
                } );
                //FIN AJOUT COLLADA
            }

            function createFbx(name, scalexyz, posxyz, turn){
                //DEBUT AJOUT FBX
				const fbxLoader = new FBXLoader();
				fbxLoader.load( './models/fbx/'+ name +'.fbx', function ( object ) {
                    var mixer = new THREE.AnimationMixer(object);
					mixer.clipAction(object.animations[0]).play();
					object.traverse( function ( node ) {
						if ( node.isMesh ) {

							node.castShadow = true;
							node.receiveShadow = true;

						}
					} );
                    object.scale.set(scalexyz[0],scalexyz[1],scalexyz[2]);
                    object.position.set(posxyz[0],posxyz[1],posxyz[2]);
                    object.rotation.y = turn;
                    scene.add( object );
                    objs.push({object, mixer});
				} );
                //FIN AJOUT FBX
            }
            
            function animate() {

                requestAnimationFrame( animate );

                if ( controls.isLocked === true ) {
                    raycaster.ray.origin.copy( controls.getObject().position );                     // Positionnement de la souris dans l'espace 3D
                    var intersections = raycaster.intersectObjects( objects );                      // Création de l'axe de la caméra souris dans l'espace
                    var onObject = intersections.length > 0;                                        // Booléen vérifiant la position au sol (pour le saut)
                    var time = performance.now();                                                   // Actualisation des performances
                    var delta = ( time - prevTime ) / 1000;                                         // Delta des performances (animation en temps réel)
                    // Velocity                                                                     //
                    velocity.x -= (velocity.x*0.01) * movSpeedX* delta;                             // Détermination de la vélocité X dans l'espace
                    velocity.z -= (velocity.z*0.01) * movSpeedZ * delta;                            // Détermination de la vélocité Z dans l'espace
                    velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass                              // Détermination de la vélocité Y dans l'espace (gravité x masse x delta)
                    direction.z = Number( moveForward ) - Number( moveBackward );                   // Quantification des objets en valeurs numériques (si j'avance ou je recule)
                    direction.x = Number( moveRight ) - Number( moveLeft );                         // Quantification des objets en valeurs numériques (si à gauche ou à droite)
                    direction.normalize();                                                          // Normalisation des vecteurs pour déplacement fluide
                    if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;   // Traitement des positions (évolution de la direction par rapport au temps)
                    if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;         // Traitement des positions (évolution de la direction par rapport au temps)
                    if ( onObject === true ) {                                                      // 
                        velocity.y = Math.max( 0, velocity.y );                                     // Vérification de la position pour éviter sauts multiples
                        canJump = true;                                                             // 
                    }                                                                               //
                    controls.moveRight( - velocity.x * delta );                                     // Mirroring des vélocités pour déplacement inversé
                    controls.moveForward( - velocity.z * delta );                                   // (Sinon déplacement inversé (gauche = droite/devant = derrière))
                    controls.getObject().position.y += ( velocity.y * delta );                      // Détermination du comportement en cas de saut (déplacement vertical)
                    if ( controls.getObject().position.y < 1000 ) {                                 // Troubleshooting pour éviter l'enfoncement dans le sol
                        velocity.y = 0;                                                             //
                        controls.getObject().position.y = 1000;                                     //
                        canJump = true;                                                             // Restauration de la possibilité de sauter
                    }                                                                               //
                    prevTime = time;                                                                // Actualisation de la frame
                }

                //
                var delta = clock.getDelta();// Système d'horloge qui trouve les secondes après le moment t et qui met à jour ce moment

                //UPDATE DU MIXER 
                objs.forEach(({mixer}) => {mixer.update(delta);});
            

                renderer.render( scene, camera );

            }

            
		</script>
	</body>
</html>
